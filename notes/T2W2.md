## Computer Science Fundamentals

Why is this important?

CS fundamental skills are crtical for any kind of progamming. In this course we focus on skills in the areas of: 
* Logic 
* Data Sctrucutres
* Algorithms

Every programmer must at lewast be familair with the topics awe cover to be effective and able ot advance their understanding of programming.

## Number Systems(bases)

### What is base?

**Base** (or radix) is simply the number of digits that a number sytem has.

There are other number systems that have a different **base**.

**Decimal** (base 10) has 10 digits: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9

![Alt text](imgs/decimal_base_system.PNG)

The reason we know that 123 is 123 in decimal is from the above image, with the 10's multiplied by the number.

**Binary** (base 2) has 2 digits: 0, 1

![Alt text](imgs/binary_base_system.PNG)

We know the number similar to the decimal system because it is multiplied but by using 2's instead of 10's

**Hexadecimal** (base 16) has 10 digits and 6 letters: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 AND A, B, C, D, E, F

![Alt text](imgs/hexadecimal_base_system.PNG)

Same however it uses 16 because it is base 16. Starting from A count goes to 10 - 15 from A to F.

Converting hex to binary is quite easy because they map perfectly as seen in the image below. 

![Alt text](imgs/convert_hex_to_binary.PNG)

### Converting from decimal to Binary

Generally the moethod from converting any base 10 (decimal) is to divide the number by the base. Keep dividing until the resulting quotient is a valid digit in the base (less tahn the base). The converted number starts with the final whole number and ends with the first remainder.

Meaning in below example last quotient is 1 therefore it starts with a 1 and the first remainder is 1 so it also ends in a 1. 

Another way of thinking about the order is that when doing the divisions is the first division is the first 2^0 and so on.


![Alt text](imgs/decimal_to_binary.PNG)

In this image remainer is 1 in 29/2 so thats the first one. THe next one is 14/2 which is remainder 0 and so on and so forth. This continues until 1 is lower than 2 so the conversion division is complete.

**Alternatively**

You are able to convert by checking the highest power that is able to fit in the the quotient and placing a 1 or 0 depending on the places and quotient. For example below using the number 25.

![Alt text](imgs/decimal_to_binary_alternative.PNG)

### Converting from decimal to Hexadecimal

Same order.

![Alt text](imgs/decimal_to_hex.PNG)

### Counting in other bases

![Alt text](imgs/Other_bases.PNG)

Counting in other bases is done by going up to the number and then going up to next 10's. 
* Base 13 uses ABC to do up to 13 base and then goes back to 10

### Adding Binary Numbers

Addition is the same however carrying numbers over is only done with 1's because 1 is the max number. Therefore a 2 carries the one over to the next line.

![Alt text](imgs/binary_adding.PNG)

### Final Thoughts
* Always keep in mind what the number might be represeting
* Each digit in a number represents the value in that positiion times the power of the base for htt position
* TO convert from decimal to another base, we divide the decimal number y the base
* To convert from another base to decimal, we mulitply each place value by the power of the base for that position, then sum the results
* When we count in a base we can use only digits that are less than the base value
* When converting from 2 non decimal bases, use decimal as a middle meeting point to convert from one to another.

## Boolean Logic



## Sets



## Big O Notation (algorithm complexity)



## Matrices



## Graphs



## Functions and Relations

***

**What is a web framework?**
* Provides basic structure and functionality we need to build a web app
* Then add business logics as hooks into framework in order to customise framework to requirements
* A library imports library (module/pack) but the program has control the whole time. In  a framework has control when and where things happen, however we attach **hooks** to customize what happens when something occurs
  * Framework controls the control flow and we just make additions
  * Library we have control and then call when we need them
* Idea is to avoid having to write a lot of boilerplate code every time
*  Several to pick from
   *  Ruby - Rails, Sinatra
   *  C# - .NET
   *  Python - Django, Flask
   *  Javascript - Express, React


# Flask

It is a python web micro-framework meaning that it has everything needed for minimal functionality. To get full functionality plugins are needed, therefore can install only what is needed to get the job done

* Rails et al provide (almost) everythin needed out of the box
* Not a "kitchen sink" framework etc Rails, .NET or Django
  * MVC (Model-View-Coontroller) - Can be overkill for small projects
  * Projects are large (lots of files) and heavyweight (needs lots of server resources)
  * Opinionated - must use subsystems chosen by framework designers (e.g. use a specific ORM to access DB)

Flask is more similar to Sinatra and Express
* Provides basic routing, request/response and a dev server
* Agnostic - Use an DB, templating library, ORM, etc
  * Comes with Jinja templating but can swap in any template library
* Additional functionality can be added with packages
* Build a server from only the components needed
* Not MVC - Strucuture app however you want
* A more lightweight, performant solution
* Idea for building RESTful API's

## Running Flask

Setting up flask is simple, just use pip install while in a .venv so that it doesn't install globally.

`python3 -m venv .venv`

Then install simply using `pip install flask`

```python
from flask import Flask

app = Flask(__name__)

@app.route("/")
def hello_world():
    return "<p>Hello, World!</p>"
```
1. Imported Flask
2. Created an instance of flask 
3. Used the `route()` decorator to tell flask what URL would trigger function
4. The function returns the message we want to display in the userâ€™s browser

To run the actual flask application
`flask --app hello run`

## Debug Mode

The debugger allows executing arbitrary Python code from the browser. It is protected by a pin, but still represents a major security risk. Do not run the development server or debugger in a production environment.

To use debug mode use debug while running the run code.

`flask --app hello run --debug`

## HTML Escaping

Flask has an inbuilt function `escape()` that is used for HTML escaping. It refers to the process of converting special characters such as `<`, `>`, `&`, and `"`, to their html counterparts. 

For example `"Hello"` is converted to `&quot;Hello&quot;`

## Routing

Modern web applications use meaningful URLs to help users.

Use the route() decorator to bind a function to a URL.


## Dynamic Routing

A technique that allows us to specify a URL ppattern rather than hard-coding URLS as a string. To do this and provide smaller reusable code we need to make use of an API client.

**API Clients**: Tool that can be used to send dummy requests to an API and inspect the response that is generated. For example the one used in the current course is POSTMAN.

To understand dynamic routing we need to stop hard-coding the entire route for example `@app.route/users/user_list`. Instead we mark our out URI as a variable with some angled brackets.

`@app.route("/<some_value>")`

* **URI**: Uniform Resource Identifier as an analogy is like a person's name that identifies the person without how to locate them, this is also a persisten identifier that can differentiate and identify files from each other.
* **URL**: Is a subset of **URI's** of which is not persistent, it is like an address that shows the location of the person. Can only be used to identify and locate web pages.

The problem with doing this however is that routes may collide with one another. For example in the below code by using /info while using the some_page function it will execute the info_page function.

```python
from flask import Flask

app = Flask(__name__)

@app.route("/<some_value>")
def some_page(some_value):
    return f"<p>You gave the value {some_value} in the route!</p>"

@app.route("/info")
def info_page():
    return "<p>This is the info page.</p>"
```

Instead a better way of doing this would be to hard-code to a point, for example hard-code to the page and then place a value. For example in the code below. We could replace `/some_page/<some_value>` with for example `users/<values>`. Meaning it would direct to users and then be a dynamic route from there.

```python
from flask import Flask

app = Flask(__name__)

@app.route("/some_page/<some_value>")
def some_page(some_value):
    return f"<p>You gave the value {some_value} in the route!</p>"

@app.route("/info")
def info_page():
    return "<p>This is the info page.</p>"
```

### **Dynamic API Routes**

Some notes to consider when using dynamic API routes:
* Unable to use spaces in request route if there is a space need to replace with `%20`
* The abort function is used as practice for error 404 handling
  ```python   
  # If there's no such artist, we return a 404 NOT FOUND error!
    if not art_list:
        abort(404)
    ```
* There is a syntax for including data type in the request `<string:some_string>`
* Strings cannot contain a slash character


## SQLAlchemy

Alchemy allows the data put in a table puts it into a database table. Conversely it also moves the data in the database table into the table in Python object (the model).

To use SQLAlchemy need to use a connection string and create an instance of it.
```python
# protocol+data base adaptor://user:password@hostname:port/database
app.config['SQLALCHEMY_DATABASE_URI'] = 'postgresql+psycopg2://trello_dev:spameggs123@localhost:5432/trello' 
# has to be exact for it to work  app.config('SQLALCHEMY_DATABASE_URI')

db = SQLAlchemy(app) # create new instance of SQLAlchemy with a connection to the app

```

**Analogy**

You request what you(python data model) want from a waiter(alchemy) the waiter translates this(to sql) bringing back to chef(posgres database result from request) and waiter (SQLAlchemy) translates it back and presents back to you (python data model)

**Setting up a table or Creating a Model**

A model is a basically a class that allows you to create objects BUT a model also creates the structure of that is going to be used as a table and its rows in the database. This is always singular and **NEEDS** to inherit from `db.model` so that it can be used as an SQLAlchemy model. A name can then be set as by default it will use the class name in snake case.

```python
class Card(db.Model): # inheriting from database SQLalchemy structure
    __tablename__ = 'cards' # declare name of table

    id = db.Column(db.Integer, primary_key=True) # data type first in .columns then if primary key must specify
    title = db.Column(db.String(100))
    description = db.Column(db.String())
    date_created = db.Column(db.Date())
```

Creates tables command
```python
# just as per sql tables we dropped first we also need to drop the tables whenever created so it becomes a new slate

@app.cli.command('create') # creates CLI customer commands, string can be anything
def create_db():
    db.drop_all() # drops tables for new slate
    db.create_all() # creates the databases that are defined above (as intepreted language)
    print('Tables created successfull')

@app.cli.command('seed') # creates instance of the Card model in memory
def seed_db():
    # created new instance of Card
    card = Card(
        title = 'Start the project',
        description = 'Stage 1 - Create an ERD',
        date_created = date.today()
    )

    # truncate the Card table same as drop table but only deletes records in table as reseeding
    db.session.query(Card).delete() # query asks what model to do it on then delete deletes the rows

    # add card to session (transaction)
    db.session.add(card) # transaction like when buying and card is declined entire transaction is cancelled
    # commit transaction to database 
    db.session.commit()
```

By using `db.session` it ensures statements are all executed (all statements must succeed) if even one fails though the entire database gets rolled back to before the statements begun.

This sytem is called transaction system meaning its step by step. It's called transaction system because -> it's all or nothing for example if buying groceries and items are added to cart, part of the transaction system is to pay however if unable to pay entire transaction is cancelled. They don't automatically get you to pay for the ones you are able to pay for. Instead it is restarted to the beginning or cancelled entirely.

`db.session.add()` adds like a git add
`db.session.commit()` commits the changes

When adding multiple objects you are able to make them into a list to add_all such as below.

```python
@app.cli.command('seed') # creates instance of the Card model in memory
def seed_db():
    # created new instance of Card
    cards = [
        Card(
            title = 'Start the project',
            description = 'Stage 1 - Create an ERD',
            date_created = date.today()
        ),

        Card(
            title = 'ORM Queries',
            description = 'Stage 2 - Implement several queries',
            date_created = date.today()
        ),

        Card(
            title = 'Marshmallow',
            description = 'Stage 3 - Implement jsonify of models',
            date_created = date.today()
        )
    ]

    # truncate the Card table same as drop table but only deletes records in table as reseeding
    db.session.query(Card).delete()

    # add card to session (transaction)
    db.session.add_all(cards)
```

**Prepared statement**: They take an SQL statement and compiles it. 
* Is more secure as the code variables are treated separately stopping SQL injection
* Once query is prepared then next query is run is uses a prepared statement similar to a compiled code. 
* SQL injection is where data is accepted from user/coming in from a route and can be used to execute malicious code such as dropping tables 

```python
@app.route('/cards') # @app.cli.command('all_cards')
def all_cards():
    # GOAL - select * from cards;
    stmt = db.select(Card) # .limit(2) # do a select query from cards limited to 2 # if only 1 its returned as an item/object

    # executes statement above
    # cards = db.session.execute(stmt)  # default tuple
    cards = db.session.scalars(stmt).all() # returns model instances # all will always return a list

    # cards = db.session.scalars(stmt).first() # returns first one

    # print(cards) 

    for card in cards: # loops over 
        print(card.title)
```

* Using a `.limit()` method after function limits the number of results to 2
* There is also a `.where()` method in statements. 

`stmt = db.select(Card).where(db.or_(Card.status != 'Done', Card.id > 2)).order_by(Card.title.desc())`

* the `,` is AND by default but using db.or changes the comma to an OR
* To mix AND + OR together needs to be for example as below.

`.where(<condition1>, db.or_(<condition2>, <condition3>)) would be where condition1 AND (condition 2 or condition 3`



## ORM's or Object Relational Mapping. 

They are used to interact between applications and databases. They make it easier to develop a database as it is written using a programming language instead of plain SQL. It is also helpful as the tables of databases can be considered as objects in OOP apps or models in an MVC application.

**Pros**
* Cleaner and less code than embedded SQL
* High level implementation, no need to worry about how things work, great for connections, migrations seeds.
* Simpler to use as no need to convert table and object
* Code reamins same or minor modifications if database changes

**Cons**
* First stages (Learning and Installing) can be time-consuming
* Still need to know about database and SQL fundamentals
* Complex queries may still need embedding of SQL

**Popular ORM's**

We will be using SQLAlchmey for now.

* SQLAlchemy: Best for Python apps and built in Flask
* Hibernate: MOost used for Java developers
* Mongooese: Used in Noke.js for an easy manamgement of MongoDB
* Sequelise: Node.js ORM as well, for relational databases
* Active Record: The built in ORM for Ruby on Rails.

### Database Connection and Models

When making a new database it is good practice to create a user that can handle the database but doesn't have access to the rest of the database.
1. Make the user `CREATE USER db_dev WITH PASSWORD '123456';`
2. Grant Permissions `GRANT ALL PRIVILEGES ON DATABASE trello_clone_db TO db_dev;` 

**Database Connection**

In Flask `Pyschopg` is needed as it is the most popular PostgreSQL database adapter for Python. `python3 -m pip install pyscopg2`

SQLAlchemy is also needed as the ORM `python3 -m pip install flask-sqlalchemy`



## Marshmallow

Similar to SQLAlchemy it cannot be used straight out of the box, needs to be instanced to jsonify.

Are able to make multiple schemas depending on what is wanted to be returned as jsonify. For example one can be used for descriptions and another can be used for titles.

By default marshmallow will also return the details by ascending order of keys.